#include "maze3.h"

#include "random.h"
#include "maze_util.h"
#include "maze_tables.h"


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
//
//  Precomputed arrays that help generalize certain maze generation proceedures.
//
//
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////




//
//There are 21 different corner configurations.  
//
//         0              1              2              3
//
//         |              |              |              |     
//         +              +           +--+              +--+  
//         |              |           |                    |  
//    --+--+--+--    --+--+--+--    --+--+--+--    --+--+--+--
//      |                    |           |              |     
//      +--+              +--+           +              +     
//         |              |              |              |     
//
//
//         4              5              6              7
//
//         |              |              |              |     
//      +--+              +              +--+           +     
//      |  |              |              |  |           |     
//    --+  +--+--    --+  +--+--    --+--+  +--    --+--+  +--
//         |           |  |              |              |  |  
//         +           +--+              +              +--+  
//         |              |              |              |     
//
//
//         8              9             10             11
//
//         |              |              |              |     
//      +--+              +--+        +--+              +--+  
//      |  |              |  |        |                    |  
//    --+  +--+--    --+--+  +--    --+--+  +--    --+  +--+--
//            |        |                 |  |        |  |     
//         +--+        +--+              +--+        +--+     
//         |              |              |              |     
//
//
//        12             13             14             15
//
//         |              |              |              |     
//      +--+--+           +              +--+        +--+     
//      |  |  |           |                 |        |        
//    --+  +  +--    --+  +  +--    --+--+--+--    --+--+--+--
//         |           |  |  |              |        |        
//         +           +--+--+           +--+        +--+     
//         |              |              |              |     
//
//
//        16             17             18             19
//
//         |              |              |              |     
//         +--+        +--+              +--+        +--+     
//            |        |                 |  |        |  |     
//    --+--+--+--    --+--+--+--    --+  +  +--    --+  +  +--
//      |                    |        |  |              |  |  
//      +--+              +--+        +--+              +--+  
//         |              |              |              |     
//
//
//        20
//
//         |     
//         +     
//         |     
//    --+--+--+--
//         |     
//         +     
//         |
//
//
//However, from the perspective of one particular maze square, there are 
//only 5 different corner configurations.
//
//         0            1            2            3            4
//
//                                +--+         +--+
//                                |  |         |  |
//    --+          --+--+       --+  +       --+  +--+    --+--+--+
//      |               |            |               |            |
//      +--+            +            +            +--+         +--+
//         |            |            |            |            |
//
//
//This array is a mapping of the 21 to the 5 for each corner.  The mapping was
//generated by hand.
//

uint8 corner_config_general_to_relative_mapping[21][NUM_CORNERS] = {
    2, 0, 1, 1,
    0, 4, 1, 1,
    1, 1, 0, 4,
    1, 1, 2, 0,
    1, 2, 0, 1,
    1, 0, 4, 1,
    4, 1, 1, 0,
    0, 1, 1, 2,
    0, 3, 0, 1,
    3, 0, 1, 0,
    0, 1, 0, 3,
    1, 0, 3, 0,
    4, 2, 0, 0,
    0, 0, 4, 2,
    0, 4, 2, 0,
    2, 0, 0, 4,
    2, 0, 2, 0,
    0, 4, 0, 4,
    4, 0, 4, 0,
    0, 2, 0, 2,
    1, 1, 1, 1,
};


//
//A "square" maze is a maze where all relative corner configurations are
//pattern 1.  Given a square maze, there are a fixed number of valid mazes.
//These mazes are identified by a "wall pattern", which has a bit for each
//of the 12 internal wall positions.  The ordering of the bits is as follows:
//The squares are also numbered from 0 to 8.
//
// +-21--+-22--+-23--+
// |     |     |     |
//14  6  2  7  5  8 17
// |     |     |     |
// +--9--+-10--+-11--+
// |     |     |     |
//13  3  1  4  4  5 16
// |     |     |     |
// +--6--+--7--+--8--+
// |     |     |     |
//12  0  0  1  3  2 15
// |     |     |     |
// +-18--+-19--+-20--+
//
//A 0 in any bit means that there is a wall in that position, 1 means no wall.
//  
//*Note: See countmaze.cpp for code to compute the valid maze patterns.*
//

uint32 valid_square_mazes[NUM_VALID_SQUARE_MAZES] = {
    0x27f, 0x2bf, 0x2fd, 0x2fe, 0x33f, 0x36f, 0x377, 0x37d, 0x37e, 0x3af,
    0x3b7, 0x3ed, 0x3ee, 0x3f5, 0x3f6, 0x47f, 0x4bf, 0x4fd, 0x4fe, 0x53f,
    0x56f, 0x577, 0x57d, 0x57e, 0x5af, 0x5b7, 0x5ed, 0x5ee, 0x5f5, 0x5f6,
    0x67b, 0x67d, 0x6bb, 0x6bd, 0x6f9, 0x6fa, 0x6fc, 0x73b, 0x73d, 0x76b,
    0x76d, 0x773, 0x775, 0x779, 0x77a, 0x77c, 0x7ab, 0x7ad, 0x7b3, 0x7b5,
    0x7e9, 0x7ea, 0x7ec, 0x7f1, 0x7f2, 0x7f4, 0x87f, 0x8bf, 0x8fd, 0x8fe,
    0x93f, 0x96f, 0x977, 0x97d, 0x97e, 0x9af, 0x9b7, 0x9ed, 0x9ee, 0x9f5,
    0x9f6, 0xa5f, 0xa6f, 0xa7b, 0xa7d, 0xa9f, 0xaaf, 0xabb, 0xabd, 0xadd,
    0xade, 0xaed, 0xaee, 0xaf9, 0xafa, 0xafc, 0xb1f, 0xb2f, 0xb3b, 0xb3d,
    0xb4f, 0xb57, 0xb5d, 0xb5e, 0xb67, 0xb6b, 0xb6e, 0xb73, 0xb75, 0xb79,
    0xb7a, 0xb7c, 0xb8f, 0xb97, 0xba7, 0xbab, 0xbad, 0xbb3, 0xbb5, 0xbcd,
    0xbce, 0xbd5, 0xbd6, 0xbe5, 0xbe6, 0xbe9, 0xbea, 0xbec, 0xbf1, 0xbf2,
    0xbf4, 0xc5f, 0xc6f, 0xc9f, 0xcaf, 0xcdd, 0xcde, 0xced, 0xcee, 0xd1f,
    0xd2f, 0xd4f, 0xd57, 0xd5d, 0xd5e, 0xd67, 0xd6d, 0xd6e, 0xd8f, 0xd97,
    0xda7, 0xdcd, 0xdce, 0xdd5, 0xdd6, 0xde5, 0xde6, 0xe5b, 0xe5d, 0xe6b,
    0xe6d, 0xe9b, 0xe9d, 0xeab, 0xead, 0xed9, 0xeda, 0xedc, 0xee9, 0xeea,
    0xeec, 0xf1b, 0xf1d, 0xf2b, 0xf2d, 0xf4b, 0xf4d, 0xf53, 0xf55, 0xf59,
    0xf5a, 0xf5c, 0xf63, 0xf65, 0xf69, 0xf6a, 0xf6c, 0xf8b, 0xf8d, 0xf93,
    0xf95, 0xfa3, 0xfa5, 0xfc9, 0xfca, 0xfcc, 0xfd1, 0xfd2, 0xfd4, 0xfe1,
    0xfe2, 0xfe4
};


//
//Depending on the corner configurations, some of the square maze patterns
//are invalidated.  This happens when relative corner configuration 0 is present 
//at 1 or more corners.  
//
//The following arrays give the subsets of valid maze patters for every 
//"clipped corner" pattern.  The clipped corner pattern is a 4-bit number.  
//A value of 1 in any bit means the corner is clipped.  A value of 0 means
//the corner is not clipped.
//
//Bit 0 is for up-left, bit 1 is for up-right, bit 2 is for down-right, 
//and bit 3 is for down-left.  The subset of valid mazes for each clipped corner 
//pattern is stored in a clipped_corner_valid_mazes_struct.
//

uint32 clipped_corner_0_valid_mazes[] = { 0x27f, 0x2bf, 0x2fd, 0x2fe, 0x33f, 0x36f, 0x377, 0x37d, 0x37e, 0x3af, 0x3b7, 0x3ed, 0x3ee, 0x3f5, 0x3f6, 0x47f, 0x4bf, 0x4fd, 0x4fe, 0x53f, 0x56f, 0x577, 0x57d, 0x57e, 0x5af, 0x5b7, 0x5ed, 0x5ee, 0x5f5, 0x5f6, 0x67b, 0x67d, 0x6bb, 0x6bd, 0x6f9, 0x6fa, 0x6fc, 0x73b, 0x73d, 0x76b, 0x76d, 0x773, 0x775, 0x779, 0x77a, 0x77c, 0x7ab, 0x7ad, 0x7b3, 0x7b5, 0x7e9, 0x7ea, 0x7ec, 0x7f1, 0x7f2, 0x7f4, 0x87f, 0x8bf, 0x8fd, 0x8fe, 0x93f, 0x96f, 0x977, 0x97d, 0x97e, 0x9af, 0x9b7, 0x9ed, 0x9ee, 0x9f5, 0x9f6, 0xa5f, 0xa6f, 0xa7b, 0xa7d, 0xa9f, 0xaaf, 0xabb, 0xabd, 0xadd, 0xade, 0xaed, 0xaee, 0xaf9, 0xafa, 0xafc, 0xb1f, 0xb2f, 0xb3b, 0xb3d, 0xb4f, 0xb57, 0xb5d, 0xb5e, 0xb67, 0xb6b, 0xb6e, 0xb73, 0xb75, 0xb79, 0xb7a, 0xb7c, 0xb8f, 0xb97, 0xba7, 0xbab, 0xbad, 0xbb3, 0xbb5, 0xbcd, 0xbce, 0xbd5, 0xbd6, 0xbe5, 0xbe6, 0xbe9, 0xbea, 0xbec, 0xbf1, 0xbf2, 0xbf4, 0xc5f, 0xc6f, 0xc9f, 0xcaf, 0xcdd, 0xcde, 0xced, 0xcee, 0xd1f, 0xd2f, 0xd4f, 0xd57, 0xd5d, 0xd5e, 0xd67, 0xd6d, 0xd6e, 0xd8f, 0xd97, 0xda7, 0xdcd, 0xdce, 0xdd5, 0xdd6, 0xde5, 0xde6, 0xe5b, 0xe5d, 0xe6b, 0xe6d, 0xe9b, 0xe9d, 0xeab, 0xead, 0xed9, 0xeda, 0xedc, 0xee9, 0xeea, 0xeec, 0xf1b, 0xf1d, 0xf2b, 0xf2d, 0xf4b, 0xf4d, 0xf53, 0xf55, 0xf59, 0xf5a, 0xf5c, 0xf63, 0xf65, 0xf69, 0xf6a, 0xf6c, 0xf8b, 0xf8d, 0xf93, 0xf95, 0xfa3, 0xfa5, 0xfc9, 0xfca, 0xfcc, 0xfd1, 0xfd2, 0xfd4, 0xfe1, 0xfe2, 0xfe4 };
uint32 clipped_corner_1_valid_mazes[] = { 0x47f, 0x4bf, 0x4fd, 0x4fe, 0x53f, 0x56f, 0x577, 0x57d, 0x57e, 0x5af, 0x5b7, 0x5ed, 0x5ee, 0x5f5, 0x5f6, 0x67b, 0x6bb, 0x6f9, 0x6fa, 0x73b, 0x76b, 0x773, 0x779, 0x77a, 0x7ab, 0x7b3, 0x7e9, 0x7ea, 0x7f1, 0x7f2, 0x87f, 0x8bf, 0x8fd, 0x8fe, 0x93f, 0x96f, 0x977, 0x97d, 0x97e, 0x9af, 0x9b7, 0x9ed, 0x9ee, 0x9f5, 0x9f6, 0xa7b, 0xabb, 0xaf9, 0xafa, 0xb3b, 0xb6b, 0xb73, 0xb79, 0xb7a, 0xbab, 0xbb3, 0xbe9, 0xbea, 0xbf1, 0xbf2, 0xc5f, 0xc6f, 0xc9f, 0xcaf, 0xcdd, 0xcde, 0xced, 0xcee, 0xd1f, 0xd2f, 0xd4f, 0xd57, 0xd5d, 0xd5e, 0xd67, 0xd6d, 0xd6e, 0xd8f, 0xd97, 0xda7, 0xdcd, 0xdce, 0xdd5, 0xdd6, 0xde5, 0xde6, 0xe5b, 0xe6b, 0xe9b, 0xeab, 0xed9, 0xeda, 0xee9, 0xeea, 0xf1b, 0xf2b, 0xf4b, 0xf53, 0xf59, 0xf5a, 0xf63, 0xf69, 0xf6a, 0xf8b, 0xf93, 0xfa3, 0xfc9, 0xfca, 0xfd1, 0xfd2, 0xfe1, 0xfe2 };
uint32 clipped_corner_2_valid_mazes[] = { 0x27f, 0x2bf, 0x2fd, 0x2fe, 0x33f, 0x36f, 0x377, 0x37d, 0x37e, 0x3af, 0x3b7, 0x3ed, 0x3ee, 0x3f5, 0x3f6, 0x47f, 0x4bf, 0x4fd, 0x4fe, 0x53f, 0x56f, 0x577, 0x57d, 0x57e, 0x5af, 0x5b7, 0x5ed, 0x5ee, 0x5f5, 0x5f6, 0x67b, 0x67d, 0x6bb, 0x6bd, 0x6f9, 0x6fa, 0x6fc, 0x73b, 0x73d, 0x76b, 0x76d, 0x773, 0x775, 0x779, 0x77a, 0x77c, 0x7ab, 0x7ad, 0x7b3, 0x7b5, 0x7e9, 0x7ea, 0x7ec, 0x7f1, 0x7f2, 0x7f4, 0xa5f, 0xa9f, 0xadd, 0xade, 0xb1f, 0xb4f, 0xb57, 0xb5d, 0xb5e, 0xb8f, 0xb97, 0xbcd, 0xbce, 0xbd5, 0xbd6, 0xc5f, 0xc9f, 0xcdd, 0xcde, 0xd1f, 0xd4f, 0xd57, 0xd5d, 0xd5e, 0xd8f, 0xd97, 0xdcd, 0xdce, 0xdd5, 0xdd6, 0xe5b, 0xe5d, 0xe9b, 0xe9d, 0xed9, 0xeda, 0xedc, 0xf1b, 0xf1d, 0xf4b, 0xf4d, 0xf53, 0xf55, 0xf59, 0xf5a, 0xf5c, 0xf8b, 0xf8d, 0xf93, 0xf95, 0xfc9, 0xfca, 0xfcc, 0xfd1, 0xfd2, 0xfd4 };
uint32 clipped_corner_3_valid_mazes[] = { 0x47f, 0x4bf, 0x4fd, 0x4fe, 0x53f, 0x56f, 0x577, 0x57d, 0x57e, 0x5af, 0x5b7, 0x5ed, 0x5ee, 0x5f5, 0x5f6, 0x67b, 0x6bb, 0x6f9, 0x6fa, 0x73b, 0x76b, 0x773, 0x779, 0x77a, 0x7ab, 0x7b3, 0x7e9, 0x7ea, 0x7f1, 0x7f2, 0xc5f, 0xc9f, 0xcdd, 0xcde, 0xd1f, 0xd4f, 0xd57, 0xd5d, 0xd5e, 0xd8f, 0xd97, 0xdcd, 0xdce, 0xdd5, 0xdd6, 0xe5b, 0xe9b, 0xed9, 0xeda, 0xf1b, 0xf4b, 0xf53, 0xf59, 0xf5a, 0xf8b, 0xf93, 0xfc9, 0xfca, 0xfd1, 0xfd2 };
uint32 clipped_corner_4_valid_mazes[] = { 0x27f, 0x2bf, 0x2fd, 0x2fe, 0x377, 0x3b7, 0x3f5, 0x3f6, 0x47f, 0x4bf, 0x4fd, 0x4fe, 0x577, 0x5b7, 0x5f5, 0x5f6, 0x67b, 0x67d, 0x6bb, 0x6bd, 0x6f9, 0x6fa, 0x6fc, 0x773, 0x775, 0x7b3, 0x7b5, 0x7f1, 0x7f2, 0x7f4, 0x87f, 0x8bf, 0x8fd, 0x8fe, 0x977, 0x9b7, 0x9f5, 0x9f6, 0xa5f, 0xa6f, 0xa7b, 0xa7d, 0xa9f, 0xaaf, 0xabb, 0xabd, 0xadd, 0xade, 0xaed, 0xaee, 0xaf9, 0xafa, 0xafc, 0xb57, 0xb67, 0xb73, 0xb75, 0xb97, 0xba7, 0xbb3, 0xbb5, 0xbd5, 0xbd6, 0xbe5, 0xbe6, 0xbf1, 0xbf2, 0xbf4, 0xc5f, 0xc6f, 0xc9f, 0xcaf, 0xcdd, 0xcde, 0xced, 0xcee, 0xd57, 0xd67, 0xd97, 0xda7, 0xdd5, 0xdd6, 0xde5, 0xde6, 0xe5b, 0xe5d, 0xe6b, 0xe6d, 0xe9b, 0xe9d, 0xeab, 0xead, 0xed9, 0xeda, 0xedc, 0xee9, 0xeea, 0xeec, 0xf53, 0xf55, 0xf63, 0xf65, 0xf93, 0xf95, 0xfa3, 0xfa5, 0xfd1, 0xfd2, 0xfd4, 0xfe1, 0xfe2, 0xfe4 };
uint32 clipped_corner_5_valid_mazes[] = { 0x47f, 0x4bf, 0x4fd, 0x4fe, 0x577, 0x5b7, 0x5f5, 0x5f6, 0x67b, 0x6bb, 0x6f9, 0x6fa, 0x773, 0x7b3, 0x7f1, 0x7f2, 0x87f, 0x8bf, 0x8fd, 0x8fe, 0x977, 0x9b7, 0x9f5, 0x9f6, 0xa7b, 0xabb, 0xaf9, 0xafa, 0xb73, 0xbb3, 0xbf1, 0xbf2, 0xc5f, 0xc6f, 0xc9f, 0xcaf, 0xcdd, 0xcde, 0xced, 0xcee, 0xd57, 0xd67, 0xd97, 0xda7, 0xdd5, 0xdd6, 0xde5, 0xde6, 0xe5b, 0xe6b, 0xe9b, 0xeab, 0xed9, 0xeda, 0xee9, 0xeea, 0xf53, 0xf63, 0xf93, 0xfa3, 0xfd1, 0xfd2, 0xfe1, 0xfe2 };
uint32 clipped_corner_6_valid_mazes[] = { 0x27f, 0x2bf, 0x2fd, 0x2fe, 0x377, 0x3b7, 0x3f5, 0x3f6, 0x47f, 0x4bf, 0x4fd, 0x4fe, 0x577, 0x5b7, 0x5f5, 0x5f6, 0x67b, 0x67d, 0x6bb, 0x6bd, 0x6f9, 0x6fa, 0x6fc, 0x773, 0x775, 0x7b3, 0x7b5, 0x7f1, 0x7f2, 0x7f4, 0xa5f, 0xa9f, 0xadd, 0xade, 0xb57, 0xb97, 0xbd5, 0xbd6, 0xc5f, 0xc9f, 0xcdd, 0xcde, 0xd57, 0xd97, 0xdd5, 0xdd6, 0xe5b, 0xe5d, 0xe9b, 0xe9d, 0xed9, 0xeda, 0xedc, 0xf53, 0xf55, 0xf93, 0xf95, 0xfd1, 0xfd2, 0xfd4 };
uint32 clipped_corner_7_valid_mazes[] = { 0x47f, 0x4bf, 0x4fd, 0x4fe, 0x577, 0x5b7, 0x5f5, 0x5f6, 0x67b, 0x6bb, 0x6f9, 0x6fa, 0x773, 0x7b3, 0x7f1, 0x7f2, 0xc5f, 0xc9f, 0xcdd, 0xcde, 0xd57, 0xd97, 0xdd5, 0xdd6, 0xe5b, 0xe9b, 0xed9, 0xeda, 0xf53, 0xf93, 0xfd1, 0xfd2 };
uint32 clipped_corner_8_valid_mazes[] = { 0x2bf, 0x2fe, 0x33f, 0x37e, 0x3af, 0x3b7, 0x3ee, 0x3f6, 0x4bf, 0x4fe, 0x53f, 0x57e, 0x5af, 0x5b7, 0x5ee, 0x5f6, 0x6bb, 0x6bd, 0x6fa, 0x6fc, 0x73b, 0x73d, 0x77a, 0x77c, 0x7ab, 0x7ad, 0x7b3, 0x7b5, 0x7ea, 0x7ec, 0x7f2, 0x7f4, 0x8bf, 0x8fe, 0x93f, 0x97e, 0x9af, 0x9b7, 0x9ee, 0x9f6, 0xa9f, 0xaaf, 0xabb, 0xabd, 0xade, 0xaee, 0xafa, 0xafc, 0xb1f, 0xb2f, 0xb3b, 0xb3d, 0xb5e, 0xb6e, 0xb7a, 0xb7c, 0xb8f, 0xb97, 0xba7, 0xbab, 0xbad, 0xbb3, 0xbb5, 0xbce, 0xbd6, 0xbe6, 0xbea, 0xbec, 0xbf2, 0xbf4, 0xc9f, 0xcaf, 0xcde, 0xcee, 0xd1f, 0xd2f, 0xd5e, 0xd6e, 0xd8f, 0xd97, 0xda7, 0xdce, 0xdd6, 0xde6, 0xe9b, 0xe9d, 0xeab, 0xead, 0xeda, 0xedc, 0xeea, 0xeec, 0xf1b, 0xf1d, 0xf2b, 0xf2d, 0xf5a, 0xf5c, 0xf6a, 0xf6c, 0xf8b, 0xf8d, 0xf93, 0xf95, 0xfa3, 0xfa5, 0xfca, 0xfcc, 0xfd2, 0xfd4, 0xfe2, 0xfe4 };
uint32 clipped_corner_9_valid_mazes[] = { 0x4bf, 0x4fe, 0x53f, 0x57e, 0x5af, 0x5b7, 0x5ee, 0x5f6, 0x6bb, 0x6fa, 0x73b, 0x77a, 0x7ab, 0x7b3, 0x7ea, 0x7f2, 0x8bf, 0x8fe, 0x93f, 0x97e, 0x9af, 0x9b7, 0x9ee, 0x9f6, 0xabb, 0xafa, 0xb3b, 0xb7a, 0xbab, 0xbb3, 0xbea, 0xbf2, 0xc9f, 0xcaf, 0xcde, 0xcee, 0xd1f, 0xd2f, 0xd5e, 0xd6e, 0xd8f, 0xd97, 0xda7, 0xdce, 0xdd6, 0xde6, 0xe9b, 0xeab, 0xeda, 0xeea, 0xf1b, 0xf2b, 0xf5a, 0xf6a, 0xf8b, 0xf93, 0xfa3, 0xfca, 0xfd2, 0xfe2 };
uint32 clipped_corner_10_valid_mazes[] = { 0x2bf, 0x2fe, 0x33f, 0x37e, 0x3af, 0x3b7, 0x3ee, 0x3f6, 0x4bf, 0x4fe, 0x53f, 0x57e, 0x5af, 0x5b7, 0x5ee, 0x5f6, 0x6bb, 0x6bd, 0x6fa, 0x6fc, 0x73b, 0x73d, 0x77a, 0x77c, 0x7ab, 0x7ad, 0x7b3, 0x7b5, 0x7ea, 0x7ec, 0x7f2, 0x7f4, 0xa9f, 0xade, 0xb1f, 0xb5e, 0xb8f, 0xb97, 0xbce, 0xbd6, 0xc9f, 0xcde, 0xd1f, 0xd5e, 0xd8f, 0xd97, 0xdce, 0xdd6, 0xe9b, 0xe9d, 0xeda, 0xedc, 0xf1b, 0xf1d, 0xf5a, 0xf5c, 0xf8b, 0xf8d, 0xf93, 0xf95, 0xfca, 0xfcc, 0xfd2, 0xfd4 };
uint32 clipped_corner_11_valid_mazes[] = { 0x4bf, 0x4fe, 0x53f, 0x57e, 0x5af, 0x5b7, 0x5ee, 0x5f6, 0x6bb, 0x6fa, 0x73b, 0x77a, 0x7ab, 0x7b3, 0x7ea, 0x7f2, 0xc9f, 0xcde, 0xd1f, 0xd5e, 0xd8f, 0xd97, 0xdce, 0xdd6, 0xe9b, 0xeda, 0xf1b, 0xf5a, 0xf8b, 0xf93, 0xfca, 0xfd2 };
uint32 clipped_corner_12_valid_mazes[] = { 0x2bf, 0x2fe, 0x3b7, 0x3f6, 0x4bf, 0x4fe, 0x5b7, 0x5f6, 0x6bb, 0x6bd, 0x6fa, 0x6fc, 0x7b3, 0x7b5, 0x7f2, 0x7f4, 0x8bf, 0x8fe, 0x9b7, 0x9f6, 0xa9f, 0xaaf, 0xabb, 0xabd, 0xade, 0xaee, 0xafa, 0xafc, 0xb97, 0xba7, 0xbb3, 0xbb5, 0xbd6, 0xbe6, 0xbf2, 0xbf4, 0xc9f, 0xcaf, 0xcde, 0xcee, 0xd97, 0xda7, 0xdd6, 0xde6, 0xe9b, 0xe9d, 0xeab, 0xead, 0xeda, 0xedc, 0xeea, 0xeec, 0xf93, 0xf95, 0xfa3, 0xfa5, 0xfd2, 0xfd4, 0xfe2, 0xfe4 };
uint32 clipped_corner_13_valid_mazes[] = { 0x4bf, 0x4fe, 0x5b7, 0x5f6, 0x6bb, 0x6fa, 0x7b3, 0x7f2, 0x8bf, 0x8fe, 0x9b7, 0x9f6, 0xabb, 0xafa, 0xbb3, 0xbf2, 0xc9f, 0xcaf, 0xcde, 0xcee, 0xd97, 0xda7, 0xdd6, 0xde6, 0xe9b, 0xeab, 0xeda, 0xeea, 0xf93, 0xfa3, 0xfd2, 0xfe2 };
uint32 clipped_corner_14_valid_mazes[] = { 0x2bf, 0x2fe, 0x3b7, 0x3f6, 0x4bf, 0x4fe, 0x5b7, 0x5f6, 0x6bb, 0x6bd, 0x6fa, 0x6fc, 0x7b3, 0x7b5, 0x7f2, 0x7f4, 0xa9f, 0xade, 0xb97, 0xbd6, 0xc9f, 0xcde, 0xd97, 0xdd6, 0xe9b, 0xe9d, 0xeda, 0xedc, 0xf93, 0xf95, 0xfd2, 0xfd4 };
uint32 clipped_corner_15_valid_mazes[] = { 0x4bf, 0x4fe, 0x5b7, 0x5f6, 0x6bb, 0x6fa, 0x7b3, 0x7f2, 0xc9f, 0xcde, 0xd97, 0xdd6, 0xe9b, 0xeda, 0xf93, 0xfd2 };

//
//Our master array of valid mazes.  The array is 16 elements long, one for each
//clipped corner pattern.
//
clipped_corner_valid_mazes_struct valid_clipped_mazes[16] = {
    sizeof(clipped_corner_0_valid_mazes)/sizeof(uint32), clipped_corner_0_valid_mazes,
    sizeof(clipped_corner_1_valid_mazes)/sizeof(uint32), clipped_corner_1_valid_mazes,
    sizeof(clipped_corner_2_valid_mazes)/sizeof(uint32), clipped_corner_2_valid_mazes,
    sizeof(clipped_corner_3_valid_mazes)/sizeof(uint32), clipped_corner_3_valid_mazes,
    sizeof(clipped_corner_4_valid_mazes)/sizeof(uint32), clipped_corner_4_valid_mazes,
    sizeof(clipped_corner_5_valid_mazes)/sizeof(uint32), clipped_corner_5_valid_mazes,
    sizeof(clipped_corner_6_valid_mazes)/sizeof(uint32), clipped_corner_6_valid_mazes,
    sizeof(clipped_corner_7_valid_mazes)/sizeof(uint32), clipped_corner_7_valid_mazes,
    sizeof(clipped_corner_8_valid_mazes)/sizeof(uint32), clipped_corner_8_valid_mazes,
    sizeof(clipped_corner_9_valid_mazes)/sizeof(uint32), clipped_corner_9_valid_mazes,
    sizeof(clipped_corner_10_valid_mazes)/sizeof(uint32), clipped_corner_10_valid_mazes,
    sizeof(clipped_corner_11_valid_mazes)/sizeof(uint32), clipped_corner_11_valid_mazes,
    sizeof(clipped_corner_12_valid_mazes)/sizeof(uint32), clipped_corner_12_valid_mazes,
    sizeof(clipped_corner_13_valid_mazes)/sizeof(uint32), clipped_corner_13_valid_mazes,
    sizeof(clipped_corner_14_valid_mazes)/sizeof(uint32), clipped_corner_14_valid_mazes,
    sizeof(clipped_corner_15_valid_mazes)/sizeof(uint32), clipped_corner_15_valid_mazes,
};

//
//Depending on the relative corner (nw, ne, se, sw), each corner configuration
//might add some walls to a maze unit's pattern.  
//
//This array specifies the walls that each corner config adds if it is present.  
//'AND' a value from this array to a wall pattern to add walls to that pattern.
//The only positions with any walls set are the ones that have zero values in 
//the identical position in the corner_config_general_to_relative_mapping array.
//

uint32 corner_wall_additions[21][NUM_CORNERS] = {
    0xffffff,          wall(5) & wall(11), 0xffffff,          0xffffff,
    wall(2) & wall(9), 0xffffff,           0xffffff,          0xffffff,
    0xffffff,          0xffffff,           wall(3) & wall(8), 0xffffff,
    0xffffff,          0xffffff,           0xffffff,          wall(0) & wall(6),
    0xffffff,          0xffffff,           wall(3) & wall(8), 0xffffff,
    0xffffff,          wall(5) & wall(11), 0xffffff,          0xffffff,
    0xffffff,          0xffffff,           0xffffff,          wall(0) & wall(6),
    wall(2) & wall(9), 0xffffff,           0xffffff,          0xffffff,
    wall(2) & wall(9), 0xffffff,           wall(3) & wall(8), 0xffffff,
    0xffffff,          wall(5) & wall(11), 0xffffff,          wall(0) & wall(6),
    wall(2) & wall(9), 0xffffff,           wall(3) & wall(8), 0xffffff,
    0xffffff,          wall(5) & wall(11), 0xffffff,          wall(0) & wall(6),
    0xffffff,          0xffffff,           wall(3) & wall(8), wall(0) & wall(6),
    wall(2) & wall(9), wall(5) & wall(11), 0xffffff,          0xffffff,
    wall(2) & wall(9), 0xffffff,           0xffffff,          wall(0) & wall(6),
    0xffffff,          wall(5) & wall(11), wall(3) & wall(8), 0xffffff,
    0xffffff,          wall(5) & wall(11), 0xffffff,          wall(0) & wall(6),
    wall(2) & wall(9), 0xffffff,           wall(3) & wall(8), 0xffffff,
    0xffffff,          wall(5) & wall(11), 0xffffff,          wall(0) & wall(6),
    wall(2) & wall(9), 0xffffff,           wall(3) & wall(8), 0xffffff,
    0xffffff,          0xffffff,           0xffffff,          0xffffff,
};

//
//Similarly, depending on the relative corner, each corner configuration might
//remove some walls from a maze unit's pattern.
//
//This array specifies the walls that each corner config removes if it is present.
//'OR' a value from this array to a wall pattern to take walls from that pattern.
//

uint32 corner_wall_removals[21][NUM_CORNERS] = {
    ~(wall(14)),            ~(wall(17)),            0,                      0,       
    ~(wall(14)),            ~(wall(17)),            0,                      0,       
    0,                      0,                      ~(wall(15)),            ~(wall(12)),
    0,                      0,                      ~(wall(15)),            ~(wall(12)),
    0,                      ~(wall(23)),            ~(wall(20)),            0,       
    0,                      ~(wall(23)),            ~(wall(20)),            0,       
    ~(wall(21)),            0,                      0,                      ~(wall(18)),
    ~(wall(21)),            0,                      0,                      ~(wall(18)),
    ~(wall(14)),            ~(wall(23) & wall(17)), ~(wall(20)),            0,       
    ~(wall(14) & wall(21)), ~(wall(17)),            0,                      ~(wall(18)),
    ~(wall(21)),            0,                      ~(wall(15)),            ~(wall(12) & wall(18)),
    0,                      ~(wall(23)),            ~(wall(15) & wall(20)), ~(wall(12)),
    ~(wall(21)),            ~(wall(23)),            ~(wall(20)),            ~(wall(18)),
    ~(wall(21)),            ~(wall(23)),            ~(wall(20)),            ~(wall(18)),
    ~(wall(14)),            ~(wall(17)),            ~(wall(15)),            ~(wall(12)),
    ~(wall(14)),            ~(wall(17)),            ~(wall(15)),            ~(wall(12)),
    ~(wall(14)),            ~(wall(17)),            ~(wall(15)),            ~(wall(12)),
    ~(wall(14)),            ~(wall(17)),            ~(wall(15)),            ~(wall(12)),
    ~(wall(21)),            ~(wall(23)),            ~(wall(20)),            ~(wall(18)),
    ~(wall(21)),            ~(wall(23)),            ~(wall(20)),            ~(wall(18)),
    0,                      0,                      0,                      0,       
};

//
//This 3x3 array maps offset in x and y direction to the maze grid square number.
//

uint32 coord_offset_to_square_index[3][3] = {
    0, 3, 6,
    1, 4, 7,
    2, 5, 8,
};

//
//This array gives wall bit indices given a maze square index and direction.
//

uint32 square_index_to_wall_index[9][NUM_DIRECTIONS] = {
    6, 0, 18, 12,
    7, 3, 19, 0,
    8, 15, 20, 3,
    9, 1, 6, 13,
    10, 4, 7, 1,
    11, 16, 8, 4,
    21, 2, 9, 14,
    22, 5, 10, 2,
    23, 17, 11, 5,
};



